Since Google officially announced Kotlin as a first-class language for Android in 2017, here at the Android team [@ASOS](https://medium.com/asos-techblog), we were really excited to use it. [Data classes](https://kotlinlang.org/docs/data-classes.html) are a great feature of Kotlin. They remove the need to manually implement lots of boilerplate code, such as `equals(), hash(), toString()`.

When using data classes you would assume `equals(), hash(), toString()` will work as expected but this is not always the case.

Let’s take the following data class, which holds a `String` and `anIntArray`:

`data class NumArray(val name: String, val values: IntArray)`

Consider the Java equivalent of the above data class:

```javascript
 public class NumArray {
    private final String name;
    private final int[] values;

    public NumArray(final String name, final int[] values) {
        this.name = name;
        this.values = values;
    }

    public String getName() {
        return name;
    }

    public int[] getValues() {
        return values;
    }

    @Override
    public boolean equals(final Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        final NumArray numArray = (NumArray) o;

        if (name != null ? !name.equals(numArray.name) : numArray.name != null) return false;
        return Arrays.equals(values, numArray.values);
    }

    @Override
    public int hashCode() {
        int result = name != null ? name.hashCode() : 0;
        result = 31 * result + Arrays.hashCode(values);
        return result;
    }
}
```

In the above example, the `constructor`, `getter`, `equals()` and `hashCode()` were automatically generated by the IntelliJ IDE. Most of the time these will work in the same way, however when comparing two instances, you would be amazed at the result:

```javascript
 val n1 = NumArray("1", intArrayOf(1,2,3,4))
 val n2 = NumArray("1", intArrayOf(1,2,3,4))
 val result = n1==n2
 println("result=$result")
```

[When running the code](https://play.kotlinlang.org/#eyJ2ZXJzaW9uIjoiMS41LjAiLCJwbGF0Zm9ybSI6ImphdmEiLCJhcmdzIjoiIiwianNDb2RlIjoiIiwibm9uZU1hcmtlcnMiOnRydWUsInRoZW1lIjoiaWRlYSIsImNvZGUiOiIvKipcbiAqIFlvdSBjYW4gZWRpdCwgcnVuLCBhbmQgc2hhcmUgdGhpcyBjb2RlLiBcbiAqIHBsYXkua290bGlubGFuZy5vcmcgXG4gKi9cblxuZnVuIG1haW4oKSB7XG4gICAgcHJpbnRsbihcIkhlbGxvLCB3b3JsZCEhIVwiKVxufSJ9), you will see the print result is `false` for the data class, but `true` for the Java class. Based on this, you see the issue with the usage of arrays in data classes.

In Kotlin (from [docs](https://kotlinlang.org/docs/equality.html))

> _arrays are always compared using_ `equals()`, _as all other objects_

It compares the array’s references, not the content. In the Java class, `Arrays.equals()` is used to check the content, not the reference. Since we created two arrays here, they have different references. The problem can be traced back to 2015 [here](https://blog.jetbrains.com/kotlin/2015/09/feedback-request-limitations-on-data-classes/). The root of the problem actually comes from a bug in the JVM.

> _`It’s a long-standing, well-known issue on the JVM: equals() works differently for arrays and collections. Collections are compared structurally, while arrays are not, equals() for them simply resorts to referential equality: this === other.`_

So, how can we solve this problem? Luckily, since Kotlin 1.1, the methods `contentEquals` and `contentHashCode` were introduced to compare two arrays for structural equality. Based on the example above, we can `override` the `equals()` and `hashCode()` methods as below:

```javascript
data class NumArray(val name: String, val values: IntArray) {

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as NumArray

        if (name != other.name) return false
        if (!values.contentEquals(other.values)) return false

        return true
    }

    override fun hashCode(): Int {
        var result = name.hashCode()
        result = 31 * result + values.contentHashCode()
        return result
    }
}
```

This means you lose one of the key benefits of using data classes; that you don’t need to override anything to use it. Since collections are compared structurally, when you have a data class like below, you don’t need to override anything to get the data class benefits.

`data class NumList(val name: String, val values: List<Int>))`

In Kotlin, when you compare two arrays, either directly or in a data class, consider the above before making the decision. In Java world, lists are preferable to arrays, which is also suggested in [`Effective Java`](https://www.amazon.co.uk/Effective-Java-Third-Joshua-Bloch/dp/0134685997). In Kotlin, you may want to do the same.

I hope you found this helpful. Feel free to leave comments or let me know if you’d like to hear more.
